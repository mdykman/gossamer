<wiki:toc max_depth="3" />

 == Introduction ==

The job of a controller should be a straightforward one; it mediates a clients application request to an application's [Model model] and passes the resulting data to the [View view].  

Most often, when a web developer wants to implement something in a different language, they are obliged to change platforms in order to accommodate that language.  This often means having to change our approach to the model and the view mechanics, not to mention the slew of configuration hassles.

Gossamer controller scripts may be written in a variety of [#Supported_Languages languages].  A controller written in one language may even invoke the controller of another and interact with the resulting data.

A typical Gossamer controller responds to client requests by gathering data from the application model into a [#Result_Values digestible structure] and returning it.  The controller may or may not select a [View view], in this case meaning: an sample output document marked up with additional attributes to format the data by example.  (See [Dexter]). Precisely how the data is rendered back to the client depends on how the client requested it.

 Continue to [View The View]

 == Controller Environment ==
Here, we will describe the environment shared by all controllers, regardless of the scripting language.
 === Paths ===
In Gossamer's default configuration, there are 4 uri prefixes which signal script execution: json, xml, rq, and render.  These prefixes are hints for the [View] and may generally be ignored while writing our controller.  All 4 paths invoke scripts under `scripts/controllers`
{{{

/xml/myscript  ->  $GOSSAMER_HOME/scripts/controllers/myscript.<ext>
/json/foo/bar  ->  $GOSSAMER_HOME/scripts/controllers/foo/bar.<ext>
}}}
In the latter example, if a script had been found at 
{{{
$GOSSAMER_HOME/scripts/controllers/foo.<ext>
}}}
Gossamer would set the path info to `'/bar'` and executed `foo.<ext>`.
 
If we had a script at 
{{{
`$GOSSAMER_HOME/scripts/controllers/module/script.<ext>`
}}}
and the following uri was invoked, `/rq/module/script/apples`, the handler would locate the script named bar (regardless of which scripting extension) and set '/apples' as the path info.  See [RequestInfo requestInfo] for more information on using the path info from within a script.

See [Scripting#Extensions extensions] for details on extension resolution.

 === Supported Languages ===

 * groovy (1.8.0)
 * javascript (rhino1_7R3)
 * jruby 1.6.4 (ruby-1.9.2-p136)
 * python(jython 2.5.2)
 * AscpectJ
 * scala
 * tcl
 * PHP
 * clojure (1.3.0)
 * scheme
 * sleep
 * jelly
 * judo
 * bean shell
 * awk
 * pnuts
 * Judo

As there remain some minor inconsistencies in implementations of the JSR 223 Scripting Engine Interface and it is vague on the subject of return values, Gossamer uses the `ScriptAdapter` to to normalize the interface and return values.  Many compliant scripting engines can be activated merely by introducing the to the class path and declaring them in the `.extensions` file (see [Scripting#Extensions extensions]). The default `SimpleScriptAdapter` handles them adequately.  Groovy, (j)ruby, clojure, bean shell, and AspectJ are examples of these. Others require custom `ScriptAdapters`: (p/j)ython, scheme, awk, etc. .  
  
 === Result Values ===

In normal operation, a gossamer controller script is expected to return an item of data; an object, an array, a map, a primitive  nested to arbitrary depth.  How the data is rendered to the client by the [View] is entirely dependent on how the script was invoked.  

The serializer that renders these objects into json or XML, has very simple rules.  It expect these types, nested at any level:
 * Lists
 * Maps
 * Arrays
 * Primitives/Primitive Objects
 * POJOs
 * DOM Nodes

Objects of other types many cause eccentric behaviour

A facility for plugging in special handlers for specific objects is under development.

 === Global Variables ===

The [Globals global variables] are only visible to controllers.  References to them, or objects they produce may be passed into library routines.

{{{
ruby:
c = $jdbc.get('user')
return getResult(c,args)
}}}
Gets a JDBC Connection (defined as userDataSource in applicationContext-user.xml) and passes it to a routine expecting a JDBC connection and a Map of parameters. 

Some of the most important of these [Globals Global Variables] are listed below.

 * [RequestArgs args]
 * [ViewManager vm]
 * [Session session]
 * [RequestInfo requestInfo]
 * [JDBC jdcb]
 * [HSF hsf] 


 === Direct Output ===

For those odd occasions when Gossamer's model of object-to-formatted output does not meet the task at hand, your controller may instead choose to generate response data directly.

 The [Globals#Writer writer] is used to effect direct-to-stream output.  The stdout of each scrip engine is bound to the HttpResponse Writer and so is designed for character output.  To effect binary output, the output stream should be acquired from the writer.

The writer is also used to set the content type of the direct response.

It should be noted that controllers so written will not respond to the view modes.  The output will be exactly as it has been coded to be.

 ==== Emitting a Text Response Directly ====
{{{
in groovy:
writer.setMimeType('text/plain')
println """
  This is a simple
  block of text
"""
//return null to signal that no further processing is required.
return null

}}}

 ==== Emitting a Binary Response Directly ====
{{{
in groovy:
writer.setMimeType('image/png');

def proc = "dot -T png".execute()
// fill the process' stdin
proc.getOutputStream() <<< """
digraph g {
  A->B
  B->C
  A->C
}
""";
// dump process stdout to web output stream 
writer.getOutputStream() << proc.getInputStream();

return null
}}}