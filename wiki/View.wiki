<wiki:toc max_depth="3" />

 == View Modes ==

Gossamer takes a different approach to the view. The format for a typical request is influenced by the client making that request.  As a typical controller script returns an object to the system, that object may be rendered in one of several ways without the need to recode the controller to accommodate it.

The 4 view modes are:
 * json
 * xml
 * render
 * rq

Any request to a controller under Gossamer, requires that the request be prefixed with one of these modes.

The 2 simplest of these request modes are demonstrated below.

 * `/json/myscript` # the result is rendered as json notation, with appropriate mime-type set.

 * `/xml/myscript` # the result is rendered as plain XML markup, with appropriate mime-type set.

The other 2 view modes are related to the view manager and are somewhat more sophisticated. They require that the controller specifies a view for that request.


 == View Manager ==

A reference for the ViewManager object may be found [ViewManager here].  What follows is a description of how it relates to the overall system.

 * `/render/myscript`
 * `/rq/myscript`


In a groovy controller, to specify a view:
{{{
vm.view="myview.html"
}}}

In ruby:
{{{
$vm.setView('myview.html')
}}}

`vm` is the view manager, one of several global variables available to all controllers, regardless of the scripting language.

The view documents may be any valid, well-formed XML, such as XHTML, RSS or a RESP response envelope. Typically, these are marked up with [http://code.google.com/p/dexter-xsl/wiki/UserManual Dexter] attributes to bind the application data to that layout.

Throughout this document, we may refer to Dexter source files as _templates_.

Please note that not all XSL must be generated by Dexter.  Manually prepared XSLT stylesheet may also be used. See [#Manual_XSL]

When that view is set, the mangager searches `$GOSSAMER_HOME/xsl/` for `myview.html`.  Assuming that we are using the simple view layout (see Layouts below), we expect to find that at `xsl/myview.html`.  This view is automatically used by [http://code.google.com/p/dexter-xsl/ Dexter] to generate an XSL file which will be used to format the output.

When invoked via `/render/myscript`, the result from the controller is rendered as XML and is then transformed, on the server-side, into the resulting document.

When invoked via `/rq/myscript`, the device identification system decides whether or not the requesting client (ie. the web browser) is itself capable of performing client-side XSL transformations.  If it is (as all modern desktop browsers are), The rendered XML is decorated with a processing instruction referencing the about-to-be-generated XSL and the client performs the rendering itself. If not, it is rendered server-side in the same manner as `render`.

If no view is specified, or if the specified view is not found, `rq` and `render` both behave exactly as `xml`.


The view document is ignored when rendering for `json` or `xml`.


 == File Layout ==

There are 2 ways of deploying view templates:
 * Simple Layout which accomodates most applications
 * Extended Layout, which lends multi-device support and white-labelling.

No configuration is needed to switch between layouts.  For any given template, first the view manager attempts to find it according to the rules of the extended layout.  If no template is found, then the simple layout is searched.  A single application  may use templates at both levels.   

 === Simple Layout ===

Under the simple layout, place XML/HTML format files directly under $GOSSAMER_HOME/xsl. An application specifying
`vm.setView('myapp/main.html');` would find the template at `$GOSSAMER_HOME/xsl/myapp/main.html.`

Very sophisticated apps can be build using the simple layout alone.

 === Extended Layout ===

The extended layout is used when we wish to either
 * differentiate between clients, provide distinct templates to different devices
 * provide a distinct set of templates for alternate look and feel.

Using the extended layout, templates are still placed under $GOSSAMER_HOME/xsl but with an additional directory structure.  The first additonal directory level selects for _style_, the second for _format_. This is the path to the template used for gossamer's default welcome page:
{{{
 xsl/default/xhtml-1.0/welcome.html
}}}

The first 2 levels under the `xsl/` directory have special meaning.
 `default` refers to the effective style which is always initially set to `default`, but may be set explicitly using the view manager.  When set, it remains sticky through the lifetime of the session.

 `xhtml-1.0` refers to the `format` attribute of the requesting device. By default, it is set to the `preferred_format` of the requesting device  (see [Device] for further information about device identification) but may be set explicitly using the view manager. When set, it applies to the current request only.

 ==== Fallback Resolution ====
When a view is set by the controller, ie. `vm.setView('welcome.html')`, the view manager considers the user's style and the requested format.  If no format has been explicitly set by the controller, the device's `preferred_format` attribute is consulted, which is typically, `xhtml-1.0`.  So we search for the template at the path:
{{{
 xsl/default/xhtml-1.0/welcome.html
}}}
 and we have found a match.

 
Consider the following directory structure:

{{{
  xsl/
    default/
      xhtml-1.0/

    special/
      xhtml-1.0/
}}}

Her we are presented
 == XSL Generation ==

 === Automatic XSL ===

Typically, when the view manager is instructed to use "foo.html", it is assumed that the file, once found, will be treated as a [http://code.google.com/p/dexter-xsl/ Dexter] source file (a template) and an XSL file eventually be generated from it.  The modified timestamp of that source file is used as part of the XSL file's name.  These same filename-formation rules are used by the Dexter Servlet which performs the actually compilation when it sees that a corresponding XSL file has not yet been generated for that name.

These filename formation rules also insure against over-zealous caches at both the network and the browser levels.  Browser caches in particular seem rather stubborn with regard to XSL files but the present naming convention eliminates the problem entirely.

 === Manual XSL ===

This is easily effected by using a name which does not directly correspond with a filename on the system. When no template is found, the `view` is appended with .'xsl' and that file is searched for.

Having saved our manually prepared stylesheet as `$GOSSAMER_HOME/xsl/mystyle.xsl`, we then specify in our controller:
 {{{
 vm.setView('mystyle');
}}}
The view manager will seek the template 'mystyle' and, upon failing to find it, will look for `mystyle.xsl` instead.  Upon finding it, that stylesheet is bound with the data, and no XSL generation takes place.

This is effective under both the simple and the extended layouts.